package graph;

import java.util.Comparator;

/** Implements a generalized traversal of a graph.  At any given time,
 *  there is a particular set of untraversed vertices---the "fringe."
 *  Traversal consists of repeatedly removing an untraversed vertex
 *  from the fringe, visting it, and then adding its untraversed
 *  successors to the fringe.  The client can dictate an ordering on
 *  the fringe, determining which item is next removed, by which kind
 *  of traversal is requested.
 *     + A depth-first traversal treats the fringe as a list, and adds
 *       and removes vertices at one end.  It also revisits the node
 *       itself after traversing all successors by calling the
 *       postVisit method on it.
 *     + A breadth-first traversal treats the fringe as a list, and adds
 *       and removes vertices at different ends.  It also revisits the node
 *       itself after traversing all successors as for depth-first
 *       traversals.
 *     + A general traversal treats the fringe as an ordered set, as
 *       determined by a Comparator argument.  There is no postVisit
 *       for this type of traversal.
 *  As vertices are added to the fringe, the traversal calls a
 *  preVisit method on the vertex.
 *
 *  Generally, the client will extend Traversal, overriding the visit,
 *  preVisit, and postVisit methods, as desired (by default, they do nothing).
 *  Any of these methods may throw StopException to halt the traversal
 *  (temporarily, if desired).  The preVisit method may throw a
 *  RejectException to prevent a vertex from being added to the
 *  fringe, and the visit method may throw a RejectException to
 *  prevent its successors from being added to the fringe.
 *  @author Andrew Berger
 */
public class Traversal<VLabel, ELabel> {
    
    /** Perform a traversal of G over all vertices reachable from V.
     *  ORDER determines the ordering in which the fringe of
     *  untraversed vertices is visited. */
    public void traverse(Graph<VLabel, ELabel> G,
                         Graph<VLabel, ELabel>.Vertex v,
                         Comparator<VLabel> order) {
        _fringe = new PriorityFringe(order);
        _graph = G;
        _marks.clear();
        continueTraversing(v);
    }
    
    /** Performs a depth-first traversal of G over all vertices
     *  reachable from V.  That is, the fringe is a sequence and
     *  vertices are added to it or removed from it at one end in
     *  an undefined order.  After the traversal of all successors of
     *  a node is complete, the node itself is revisited by calling
     *  the postVisit method on it. */
    public void depthFirstTraverse(Graph<VLabel, ELabel> G,
                                   Graph<VLabel, ELabel>.Vertex v) {
        _fringe = new LIFO();
        _graph = G;
        _marks.clear();
        continueTraversing(v);
    }

    /** Performs a breadth-first traversal of G over all vertices
     *  reachable from V.  That is, the fringe is a sequence and
     *  vertices are added to it at one end and removed from it at the
     *  other in an undefined order.  After the traversal of all successors of
     *  a node is complete, the node itself is revisited by calling
       *  the postVisit method on it. */
    public void breadthFirstTraverse(Graph<VLabel, ELabel> G,
                                     Graph<VLabel, ELabel>.Vertex v) {
        _fringe = new FIFO();
        _graph = G;
        _marks.clear();
        continueTraversing(v);
    }

    /** Continue the previous traversal starting from V.
     *  Continuing a traversal means that we do not traverse
     *  vertices or edges that have been traversed previously. */
    public void continueTraversing(Graph<VLabel, ELabel>.Vertex v) {
        _finalVertex = null;
        _finalEdge = null;
        boolean explored = false;
        try {
            if (!isMarked(v) && !isExplored(v)) {
                mark(v);
                _fringe.push(v);
            }
            Vertex<VLabel> curr = null;
            while (_fringe.peek() != null) {
                explored = true;
                visit(curr);
                for (Edge<VLabel, ELabel> e: _grap.edges(curr)) {
                    if (!isMarked(e) && preVisistation(e, curr)) {
                        explored = false;
                        mark(e);
                        Vertex<VLabel> w = e.getV(curr);
                        if (!isMarked(w) && !isExplored(w)) {
                            mark(w);
                            _fringe.push(w);
                            _edges.push(e);
                            break;
                        }
                    }
                }
                if (explored == true) {
                    explored(curr);
                    Vertex<VLabel> discarded = _fringe.pop();
                    Edge<VLabel, ELabel> backEdge = _edges.pop();
                    postVisitation(curr);
                }
            }

        }
    }

    /** If the traversal ends prematurely, returns the Vertex argument to
     *  preVisit that caused a Visit routine to return false.  Otherwise,
     *  returns null. */
    public Graph<VLabel, ELabel>.Vertex finalVertex() {
        return _finalVertex;
    }

    /** If the traversal ends prematurely, returns the Edge argument to
     *  preVisit that caused a Visit routine to return false. If it was not
     *  an edge that caused termination, returns null. */
    public Graph<VLabel, ELabel>.Edge finalEdge() {
        return _finalEdge;
    }

    /** Returns the graph currently being traversed.  Undefined if no traversal
     *  is in progress. */
    protected Graph<VLabel, ELabel> theGraph() {
        return _graph;
    }

    /** Method to be called when adding the node at the other end of E from V0
     *  to the fringe. If this routine throws a StopException,
     *  the traversal ends.  If it throws a RejectException, the edge
     *  E is not traversed. The default does nothing.
     */
    protected void preVisit(Graph<VLabel, ELabel>.Edge e,
                            Graph<VLabel, ELabel>.Vertex v0) {
    }

    /** Method to be called when visiting vertex V.  If this routine throws
     *  a StopException, the traversal ends.  If it throws a RejectException,
     *  successors of V do not get visited from V. The default does nothing. */
    protected void visit(Graph<VLabel, ELabel>.Vertex v) {
    }

    /** Method to be called immediately after finishing the traversal
     *  of successors of vertex V in pre- and post-order traversals.
     *  If this routine throws a StopException, the traversal ends.
     *  Throwing a RejectException has no effect. The default does nothing.
     */
    protected void postVisit(Graph<VLabel, ELabel>.Vertex v) {
    }

    /** Returns true iff V is marked.*/
    private boolean isMarked(Vertex<Vlabel> v) {
        return _marks.get(v.getId());
    }
    
    /** Returns true iff E is marked. */
    private boolean isMarked(Edge<VLabel, ELabel> e) {
        return _marks.get(e.getId());
    }

    /** Marks vertice V. */
    private void mark(Vertex<VLabel> v) {
        _marks.set(v.getId());
    }

    /** Marks edge E.*/
    private void mark(Edge<VLabel, ELabel> e) {
        _marks.get(e.getId());
    }
    
    /** True iff vertex V has been explored.*/
    private boolean isExplored(Vertex<VLabel> v) {
        return _explored.get(v.getId());
    }

    /** The Vertex (if any) that terminated the last traversal. */
    protected Graph<VLabel, ELabel>.Vertex _finalVertex;
    /** The Edge (if any) that terminated the last traversal. */
    protected Graph<VLabel, ELabel>.Edge _finalEdge;
    /** The graph currently being traversed. */
    protected Graph<VLabel, ELabel> _graph;
    /** Element at i true iff Vertex/edge i has been traversed. */
    private BitSet _marks = new BitSet();
    /** Element at i ture iff all of the edges of Vertex i have been traveresed. */
    private Bitset _explored = new BitSet();

    /** The fringe. Particular queue implementation changes based on traversal. */
    protected Fringe<Graph<VLabel, ELabel>.Vertex> _fringe;

    private interface Fringe<Graph<VLabel, ELabel>.Vertex> {

        /** Push V onto the stack I am representing. */
        public abstract void push(Graph<VLabel, ELabel>.Vertex v);

        /** Returns the first element of the stack without removing it.*/
        public abstract Graph<VLabel, ELabel>.Vertex peek();

        /** Return and remove first element of the stack.*/
        public abstract Graph<VLabel, ELabel>.Vertex pop();

        private Queue<Graph<VLabel, ELabel>.Vertex> _stack
    }

    public class LIFO<Graph<VLabel, ELabel>.Vertex> implements Fringe<Graph<VLabel, ELabel>.Vertex> {
        
        /** A new LIFO fringe.*/
        LIFO() {
            _stack = new ArrayDeque<Graph<VLabel, ELabel>.Vertex>();
        }

        public void push(Graph<VLabel, ELabel> v) {
            _stack.push(v);
        }

        public Graph<VLabel, ELabel>.Vertex peek() {
            return _stack.peek();
        }

        public Graph<VLabel, ELabel>.Vertex pop() {
            return _stack.pop();
        }
    }

    public class FIFO<Graph<VLabel, ELabel>.Vertex> implements Fringe<Graph<VLabel, ELabel>.Vertex> { 
        
        /** A few FIFO fringe.*/
        FIFO () {
            _stack = new ArrayDeque<Graph<VLabel, ELabel>.Vertex>();
        }

        public void push(Graph<VLabel, ELabel> v) {
            _stack.push(v);
        }
        
        public Graph<VLabel, ELabel>.Vertex> peek() {
            _stack.peekLast();
        }
        
        public Graph<VLabel, ELabel>.Vertex> pop() {
            _stack.pollLast();
        }
    } 

    public class OrderedFringe<Graph<VLabel, ELabel>.Vertex> implements Fringe<Graph<VLabel, ELabel.Vertex> {
        
        OrderedFringe(Comparator<VLabel> c) {
            _stack = new PriorityQueue(11, c);
        }
        
        public void push(Graph<VLabel, ELabel> v) {
            _stack.add(v);
        }

        public Graph<VLabel, ELabel>.Vertex peek() {
            return _stack.peek();
        }

        public Graph<VLabel, ELabel>.Vertex pop() {
            return _stack.poll();
        }

    }
}
